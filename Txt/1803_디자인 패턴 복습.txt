/*****************************
* 디자인 패턴 복습 *
*****************************
* 날짜 : 2018.03.06
* 목표 : 디자인 패턴 복습 시작. Strategy, Observer, Decorator
     ******* 코멘트 *******
아니 분명 5시 50분 퇴근해서 6시 전에 집 왔는데,
저녁 먹고 이것저것 하면서 쉬니까 7시 46분이다. 6시 ~ 8시 공부가 본래 목표였는데...
늦어도 6시 30분엔 공부하겠지 했는데 벌써 8시가 다 돼가잖어!

어쨌든, 몹시 올드스쿨한 느낌으로, Windows Notepad, 즉, 윈도우 기본 메모장에다가 필기를 해본다.
오늘의 목표는 음... Strategy, Observer, Decorator로 잡았는데... 못먹어도 고. 한번 해보자.

Strategy 패턴은 무엇인가?
스트래티지 패턴은 디자인 패턴을 배우면서 가장 첫 번째로 배운 패턴이었다.
오리 시뮬레이터가 예제였다. 어떻게 해야 고무오리, 나무오리가 꽥 소리를 내지 않게끔 만들 수 있을까 하는 문제.
디자인 원칙에 따라 클래스의 변하는 부분,
오리 시뮬레이터에선 Fly()와 Quack() 메소드를 분리시켰다. 캡슐화.
그리고 분리한 부분을 클래스 집합으로 만들었다.

interface IFlyBehavior

이렇게. 어렴풋이 기억나는 디자인 원칙, [구현이 아닌 인터페이스에 맞춰 프로그래밍하라.]
IFlyBehavior는 행동 클래스들이 구현할 인터페이스임과 동시에, 행동 클래스 그 자체를 나타낸다.
간단히 말해, 기존의 오리 클래스에서 IFlyBehavior 타입 변수(flyBehavior)를 가지게 되는 것.
그리고 IFlyBehavior 인터페이스에 맞춰서 오리 클래스 내부에서 코드를 짜게 된다.
추상 오리 클래스의 메소드에서
public void PerformFly()
{
	flyBehavior.Fly();
}
이렇게 행동하도록 만들고,
파생 오리 클래스의 생성자에서
flyBehavior = new FlyWithWings(name);
이렇게 할당하는거지.

스트래티지 패턴은 프로그램에서 동적으로 행동을 지정할 수 있게 만들어 주기도 한다.
행동을 일종의 변수로써 할당할 수 있으니까.

그리고 디자인 패턴을 배우면서 끊임없이 사용했던 단어 구성.
디자인 원칙에 따르면 [상속보다는 구성을 활용하라.]라고 하는데,
구성은 간단하게 말해서, 클래스 내부에 flyBehavior같이 다른 클래스를 타입으로 가지는 변수를 포함하는 방식이다.

롤챔스 보면서 하고싶은데, Unstream이 말을 안듣는다. 확실히 훈련소 한달 갔다와서 컴퓨터가 많이 않좋아졌어.

===

Observer 패턴으로 넘어가보자.
옵저버 패턴은... 일단 예제는 Wheater-O-Rama의 기상 스테이션 시스템 구축이었다.
대신 챕터 중간에 신문사에 비유하면서 옵저버 패턴을 설명했었다.

옵저버 패턴은 주제(Subject)와 옵저버(Observer)로 이루어진다.
여기서 신문사에 대입하면 주제를 신문사, 옵저버를 구독자에 비유할 수 있다.
1. 신문사가 사업을 시작하고 신문을 찍어내기 시작한다.
2. 독자가 특정 신문사에 구독 신청을 하면 매번 새로운 신문이 나올 때 마다 배달을 받을 수 있다.
   계속 구독자로 남아있는 이상 계속해서 신문을 받을 수 있다.
3. 신문을 더 이상 보고 싶지 않으면 구독 해지 신청을 한다.
4. 신문사가 계속 영업을 하는 이상 여러 개인 독자, 호텔, 항공사 미 기타 회사등에서부터 꾸준히 구독 및 해지가 계속된다.

그러니까 간단히 말해서, 옵저버는 Observable한 객체, 즉 주제를 계속 관찰하다가,
주제에게 어떠한 일이 일어나면(보통 값이 바뀐다거나) 그에 맞게 동작한다는 것.

사실 이 설명은 살짝 헷갈릴수도 있는데, 옵저버가 등록되는 쪽은 주제 클래스다.
흠... 더 자세히 설명해보면...
옵저버가 Observable에게 관측하고 싶다고 요청하고 관측을 시작한다.
Observable... 그냥 주제라고 말하자. 주제에선 누가 자신을 관측중인지 저장한다.
관측을 그만두고 싶으면 옵저버가 주제에게 "나 이제 너 그만 관찰할게" 라고 말하면 된다.
그러면 주제에서는 해당 옵저버를 리스트에서 제외하면 된다.

설명하는 사람에 따라 옵저버가 직접 관측한다 라고 말할 수도 있고,
주제가 옵저버에게 데이터를 준다 라고 설명할 수도 있는데,
결과적으로 나타나는 행동은 똑같다고 보면 된다.

그리고 어... 옵저버이면서 주제인 객체가 있을 수도 있고...

옵저버 패턴에서 중요한건 옵저버 패턴을 구현하는 방법보다는 역시,
미리 제공되는 옵저버를 사용하는 방법.
C#에서 IObservable과 IObserver를 쓰는법을 보자. 코드를 보자 이건.

일단 템플릿처럼 T가 있는데, 이 T가 바로 옵저버 패턴에서 사용할 데이터의 타입.
이건 구조체, 클래스로 따로 타입을 만들거나, 기존 타입을 쓰면 된다.

IObservable은 주제를 나타내는 인터페이스로, 
옵저버들의 리스트와,
(private List<IObserver<CSWeatherData>> observers;)
Subscribe 메소드를 가지는데,
Subscribe 메소드의 리턴 타입은 Unsubscriber라는 클래스다.
Unsubscriber는 private 멤버 클래스로, IDisposable 인터페이스를 구현한다.
즉, Subscribe의 리턴 타입은 IDsiposable로 볼 수 있고,
Subscribe를 호출했을 때 리턴 받은 그 객체를 Dispose 함으로써 구독을 해제할 수 있다.
이런건 진짜 다시 짚어보니까 잘만들었다는 생각밖에 들지 않는다...

IObserver 인터페이스를 구현하는 클래스는
OnError(), OnNext(), OnCompleted() 메소드를 구현해야한다.
어떻게 IObserver가 IObservable에 등록되게 할지는 자유롭게 구현하는듯.

일단 On 시리즈들은 IObservable에서 호출하게 될 메소드들이다.
간단하게 말해서, OnNext()가 바로 IObservable의 데이터가 변경되었을 때 호출될 메소드이다.
따라서 OnNext()는 파라미터로 T 타입의 변수를 받는다.

마지막으로 옵저버 패턴의 주의점,
옵저버 패턴을 사용할 땐 옵저버에게 연락이 가는 순서에 의존하면 안된다.
애초에 순서랄게 없는 걸로 봐야한다. 그냥 주의점이라고...

===

Decorator를 끝으로 살펴보자.

스타벅스에서 커피에 첨가물을 추가하는 과정을 어떻게 나타낼까?
스타벅스 커피 주문은 몹시 어려운 구석이 있다. 그냥 따뜻한 아이스 아메리카노 한 잔 주세요는 부족하단 말이다.

음료를 만드는 과정은 다음과 같다.
1. 얼음
2. 물
3. 에스프레소 한 잔
4. 시럽
5. 빨대
어... 물론 아메리카노는 단품으로 계산하니까 다른 예로...

1. 다크 로스트...
2. 모카에...
3. 휘핑크림 올려주세요.
4. 얼마에요?
이걸 프로그래밍으로 표현하면 다음과 같다.
1. DarkRoast 객체에서 시작
2. Mocha 객체를 만들고 그 객체로 DarkRoast를 감싼다. Mocha 객체가 바로 데코레이터.
   DarkRoast와 Mocha는 같은 형식을 가진다. (Beverage)
3. 휘핑크림도 올려야 하니 Whip 객체를 만들어 Mocha를 감싼다.
   이렇게 되면 구조는 Whip[ Mocha[ DarkRoast ] ]
4. 가격 계산을 한다. 이 부분이 데코레이터 패턴에서 가장 중요한 동작이 담겨있는 부분이 아닌가 생각해본다.
   먼저 가장 밖에 있는 데코레이터 Whip의 Cost() 함수를 호출한다.
   Whip의 Cost()에서는 그 객체가 장식하고 있는 개체에게 가격 계산을 위임한다.
   즉, Whip.Cost() =호출=> Mocha.Cost() =호출=> DarkRoast.Cost() =리턴=> Mocha.Cost() =리턴=> Whip.Cost()
   마치 재귀함수가 동작하는 것과 비슷하다.

백문이 불여일견
public override double Cost()
{
    return .89;
}
이게 음료의 Cost() 메소드. 추가로 호출하지 않고 바로 가격을 리턴한다.
public override double Cost()
{
    return .20 + beverage.Cost();
}
그리고 이게 데코레이터의 Cost() 메소드. 꾸며주고 있는 객체의 가격을 계산한 다음, 거기에 자신의 가격을 더한다.
따라서, 데코레이터와 음료는 서로 같은 조상 클래스로부터 Cost()를 상속받아 재정의했다는걸 알 수 있다.
그리고 음료와 달리 데코레이터에는 자신이 꾸며줄 객체를 담을 변수를 가지고 있다는 것도 알 수 있다. beverage가 바로 그것.

데코레이터 패턴은 쉽다.
데코레이터 패턴의 부작용으로는...
1. 자잘한 클래스들이 시스템에 너무 많이 추가될 위험이 있다. 즉, 복잡해진다.
2. 구성 요소의 클라이언트 입장에서는 데코레이터의 존재를 알 수 없다.
   그말인 즉슨, 특정 형식에 의존하는 코드에 데코레이터를 적용하기는 곤란하다는것.
3. 구성 요소를 초기화하는 코드가 복잡해진다. 계속 감싸고 감싸고...
   이런 단점을 해결하기 위해선 팩토리 같은 생성 관련 패턴을 사용하는 방법을 쓸 수 있다.

오늘은 끝~
현재시간은 9시 23분. 한시간 반 정도 공부한듯.
******************************/