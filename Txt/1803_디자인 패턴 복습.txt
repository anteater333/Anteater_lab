/*****************************
* 디자인 패턴 복습 *
*****************************
* 날짜 : 2018.03.06
* 목표 : 디자인 패턴 복습 시작. Strategy, Observer, Decorator
     ******* 코멘트 *******
아니 분명 5시 50분 퇴근해서 6시 전에 집 왔는데,
저녁 먹고 이것저것 하면서 쉬니까 7시 46분이다. 6시 ~ 8시 공부가 본래 목표였는데...
늦어도 6시 30분엔 공부하겠지 했는데 벌써 8시가 다 돼가잖어!

어쨌든, 몹시 올드스쿨한 느낌으로, Windows Notepad, 즉, 윈도우 기본 메모장에다가 필기를 해본다.
오늘의 목표는 음... Strategy, Observer, Decorator로 잡았는데... 못먹어도 고. 한번 해보자.

===

Strategy 패턴은 무엇인가?
스트래티지 패턴은 디자인 패턴을 배우면서 가장 첫 번째로 배운 패턴이었다.
오리 시뮬레이터가 예제였다. 어떻게 해야 고무오리, 나무오리가 꽥 소리를 내지 않게끔 만들 수 있을까 하는 문제.
디자인 원칙에 따라 클래스의 변하는 부분,
오리 시뮬레이터에선 Fly()와 Quack() 메소드를 분리시켰다. 캡슐화.
그리고 분리한 부분을 클래스 집합으로 만들었다.

interface IFlyBehavior

이렇게. 어렴풋이 기억나는 디자인 원칙, [구현이 아닌 인터페이스에 맞춰 프로그래밍하라.]
IFlyBehavior는 행동 클래스들이 구현할 인터페이스임과 동시에, 행동 클래스 그 자체를 나타낸다.
간단히 말해, 기존의 오리 클래스에서 IFlyBehavior 타입 변수(flyBehavior)를 가지게 되는 것.
그리고 IFlyBehavior 인터페이스에 맞춰서 오리 클래스 내부에서 코드를 짜게 된다.
추상 오리 클래스의 메소드에서
public void PerformFly()
{
	flyBehavior.Fly();
}
이렇게 행동하도록 만들고,
파생 오리 클래스의 생성자에서
flyBehavior = new FlyWithWings(name);
이렇게 할당하는거지.

스트래티지 패턴은 프로그램에서 동적으로 행동을 지정할 수 있게 만들어 주기도 한다.
행동을 일종의 변수로써 할당할 수 있으니까.

그리고 디자인 패턴을 배우면서 끊임없이 사용했던 단어 구성.
디자인 원칙에 따르면 [상속보다는 구성을 활용하라.]라고 하는데,
구성은 간단하게 말해서, 클래스 내부에 flyBehavior같이 다른 클래스를 타입으로 가지는 변수를 포함하는 방식이다.

롤챔스 보면서 하고싶은데, Unstream이 말을 안듣는다. 확실히 훈련소 한달 갔다와서 컴퓨터가 많이 않좋아졌어.

===

Observer 패턴으로 넘어가보자.
옵저버 패턴은... 일단 예제는 Wheater-O-Rama의 기상 스테이션 시스템 구축이었다.
대신 챕터 중간에 신문사에 비유하면서 옵저버 패턴을 설명했었다.

옵저버 패턴은 주제(Subject)와 옵저버(Observer)로 이루어진다.
여기서 신문사에 대입하면 주제를 신문사, 옵저버를 구독자에 비유할 수 있다.
1. 신문사가 사업을 시작하고 신문을 찍어내기 시작한다.
2. 독자가 특정 신문사에 구독 신청을 하면 매번 새로운 신문이 나올 때 마다 배달을 받을 수 있다.
   계속 구독자로 남아있는 이상 계속해서 신문을 받을 수 있다.
3. 신문을 더 이상 보고 싶지 않으면 구독 해지 신청을 한다.
4. 신문사가 계속 영업을 하는 이상 여러 개인 독자, 호텔, 항공사 미 기타 회사등에서부터 꾸준히 구독 및 해지가 계속된다.

그러니까 간단히 말해서, 옵저버는 Observable한 객체, 즉 주제를 계속 관찰하다가,
주제에게 어떠한 일이 일어나면(보통 값이 바뀐다거나) 그에 맞게 동작한다는 것.

사실 이 설명은 살짝 헷갈릴수도 있는데, 옵저버가 등록되는 쪽은 주제 클래스다.
흠... 더 자세히 설명해보면...
옵저버가 Observable에게 관측하고 싶다고 요청하고 관측을 시작한다.
Observable... 그냥 주제라고 말하자. 주제에선 누가 자신을 관측중인지 저장한다.
관측을 그만두고 싶으면 옵저버가 주제에게 "나 이제 너 그만 관찰할게" 라고 말하면 된다.
그러면 주제에서는 해당 옵저버를 리스트에서 제외하면 된다.

설명하는 사람에 따라 옵저버가 직접 관측한다 라고 말할 수도 있고,
주제가 옵저버에게 데이터를 준다 라고 설명할 수도 있는데,
결과적으로 나타나는 행동은 똑같다고 보면 된다.

그리고 어... 옵저버이면서 주제인 객체가 있을 수도 있고...

옵저버 패턴에서 중요한건 옵저버 패턴을 구현하는 방법보다는 역시,
미리 제공되는 옵저버를 사용하는 방법.
C#에서 IObservable과 IObserver를 쓰는법을 보자. 코드를 보자 이건.

일단 템플릿처럼 T가 있는데, 이 T가 바로 옵저버 패턴에서 사용할 데이터의 타입.
이건 구조체, 클래스로 따로 타입을 만들거나, 기존 타입을 쓰면 된다.

IObservable은 주제를 나타내는 인터페이스로, 
옵저버들의 리스트와,
(private List<IObserver<CSWeatherData>> observers;)
Subscribe 메소드를 가지는데,
Subscribe 메소드의 리턴 타입은 Unsubscriber라는 클래스다.
Unsubscriber는 private 멤버 클래스로, IDisposable 인터페이스를 구현한다.
즉, Subscribe의 리턴 타입은 IDsiposable로 볼 수 있고,
Subscribe를 호출했을 때 리턴 받은 그 객체를 Dispose 함으로써 구독을 해제할 수 있다.
이런건 진짜 다시 짚어보니까 잘만들었다는 생각밖에 들지 않는다...

IObserver 인터페이스를 구현하는 클래스는
OnError(), OnNext(), OnCompleted() 메소드를 구현해야한다.
어떻게 IObserver가 IObservable에 등록되게 할지는 자유롭게 구현하는듯.

일단 On 시리즈들은 IObservable에서 호출하게 될 메소드들이다.
간단하게 말해서, OnNext()가 바로 IObservable의 데이터가 변경되었을 때 호출될 메소드이다.
따라서 OnNext()는 파라미터로 T 타입의 변수를 받는다.

마지막으로 옵저버 패턴의 주의점,
옵저버 패턴을 사용할 땐 옵저버에게 연락이 가는 순서에 의존하면 안된다.
애초에 순서랄게 없는 걸로 봐야한다. 그냥 주의점이라고...

===

Decorator를 끝으로 살펴보자.

스타벅스에서 커피에 첨가물을 추가하는 과정을 어떻게 나타낼까?
스타벅스 커피 주문은 몹시 어려운 구석이 있다. 그냥 따뜻한 아이스 아메리카노 한 잔 주세요는 부족하단 말이다.

음료를 만드는 과정은 다음과 같다.
1. 얼음
2. 물
3. 에스프레소 한 잔
4. 시럽
5. 빨대
어... 물론 아메리카노는 단품으로 계산하니까 다른 예로...

1. 다크 로스트...
2. 모카에...
3. 휘핑크림 올려주세요.
4. 얼마에요?
이걸 프로그래밍으로 표현하면 다음과 같다.
1. DarkRoast 객체에서 시작
2. Mocha 객체를 만들고 그 객체로 DarkRoast를 감싼다. Mocha 객체가 바로 데코레이터.
   DarkRoast와 Mocha는 같은 형식을 가진다. (Beverage)
3. 휘핑크림도 올려야 하니 Whip 객체를 만들어 Mocha를 감싼다.
   이렇게 되면 구조는 Whip[ Mocha[ DarkRoast ] ]
4. 가격 계산을 한다. 이 부분이 데코레이터 패턴에서 가장 중요한 동작이 담겨있는 부분이 아닌가 생각해본다.
   먼저 가장 밖에 있는 데코레이터 Whip의 Cost() 함수를 호출한다.
   Whip의 Cost()에서는 그 객체가 장식하고 있는 개체에게 가격 계산을 위임한다.
   즉, Whip.Cost() =호출=> Mocha.Cost() =호출=> DarkRoast.Cost() =리턴=> Mocha.Cost() =리턴=> Whip.Cost()
   마치 재귀함수가 동작하는 것과 비슷하다.

백문이 불여일견
public override double Cost()
{
    return .89;
}
이게 음료의 Cost() 메소드. 추가로 호출하지 않고 바로 가격을 리턴한다.
public override double Cost()
{
    return .20 + beverage.Cost();
}
그리고 이게 데코레이터의 Cost() 메소드. 꾸며주고 있는 객체의 가격을 계산한 다음, 거기에 자신의 가격을 더한다.
따라서, 데코레이터와 음료는 서로 같은 조상 클래스로부터 Cost()를 상속받아 재정의했다는걸 알 수 있다.
그리고 음료와 달리 데코레이터에는 자신이 꾸며줄 객체를 담을 변수를 가지고 있다는 것도 알 수 있다. beverage가 바로 그것.

데코레이터 패턴은 쉽다.
데코레이터 패턴의 부작용으로는...
1. 자잘한 클래스들이 시스템에 너무 많이 추가될 위험이 있다. 즉, 복잡해진다.
2. 구성 요소의 클라이언트 입장에서는 데코레이터의 존재를 알 수 없다.
   그말인 즉슨, 특정 형식에 의존하는 코드에 데코레이터를 적용하기는 곤란하다는것.
3. 구성 요소를 초기화하는 코드가 복잡해진다. 계속 감싸고 감싸고...
   이런 단점을 해결하기 위해선 팩토리 같은 생성 관련 패턴을 사용하는 방법을 쓸 수 있다.

오늘은 끝~
현재시간은 9시 23분. 한시간 반 정도 공부한듯.
******************************/

*****************************
* 날짜 : 2018.03.07
* 목표 : 생성 관련 디자인 패턴
     ******* 코멘트 *******
어쩌다 보니 또 일정이 많이 딜레이됐다. 후...
그냥 오늘 일도 힘들었고... 집에 와서도 정신 하나도 없고...

어쨌든 오늘 복습할 내용은 생성 관련 디자인패턴으로, 4~5장에서 배웠던 내용들이다.
4장에서는 팩토리 패턴에 대해서 배웠고, 5장에서는 싱글턴에 대해 배웠다.

오늘 오전엔 다행히 시간이 좀 남아서 그 시간동안 좀 몇가지를 봤었다.
일단 팩토리 패턴은 조금 어렵고, 내용도 많으니까 싱글턴 패턴에 대해서 먼저 알아보도록 하자.

===

Singleton 패턴은 몹시 쉽다.
개념적으로는 "유일한 객체" 하나만 알고 있으면 되고,
구현에 있어서는 "private 생성자" 하나만 알고 있으면 될 것 같다.

private 생성자니까 당연히 클라이언트가 new 키워드로 생성하지 못하고,
해당 클래스의 인스턴스를 제공하는 static 메소드가 있어야한다.

private static Singleton uniqueInstance; // 유일한 인스턴스를 저장하기 위한 정적변수
public static Singleton Instance() { ... } // uniqueInstance가 null인지 판단한 다음 객체를 생성한다.

이렇게 끝은 당연히 아니고, Instance() 메소드를 동기화 할 필요가 있다.
C#에서는
[MethodImpl(MethodImplOptions.Synchronized)]
라는 키워드를 사용하고 volatile 키워드로 인스턴스를 담을 변수를 선언하며, DCL(Double-checking locking)을 사용한다.

===

Factory 패턴은 객체를 생성하는 과정을 캡슐화하는 패턴이라고 생각하면 된다.
Factory Method 패턴과 Abstract Factory 패턴이 있는데... 솔직히 말하자면 잘 모르겠음. 아마 디자인 패턴 공부하면서 추상 팩토리 패턴을 가장 많이 어려워하지 않았나 생각된다.

Factory Method는 간단하다. 비교적.
패턴은 Creator와 Product 클래스로 이루어져 있다.
여기서 Creator에 들어있는 Product를 생성하는 메소드가 바로 factoryMethod()이다.
피자가게 예제에서는 바로 CreatePizza(string type)
그리고 물론 OOP니까, ConcreteProduct, ConcreteCreator에서 구현이 되지만 둘은 서로 상대를 Creator, Product 즉, 추상적인 객체로 여기게 된다.
무슨말인지는 이해했으나 설명은 깔끔하게 못하겠다.

흠... Abstract Factory에 대해서 다시 알아보자.
Factory Method와 Abstract Factory의 차이점이라면, 아마 팩토리 클래스가 있느냐는 점이 아닐까.

팩토리 메소드는 말 그대로 팩토리 역할을 하는 메소드를 통해 객체를 생성했고, 추상 팩토리에서는 팩토리 역할을 하는 추상 클래스를 통해 객체를 생성한다.

참고로 그리고 그 공장에서는 단일 품목만 만들지 않는다.

백문이 불여일견... 사실 집중이 좀 안됨...
    partial class Class04
    {
        private void Section02()
        {
            Console.WriteLine(" = Section #02 = ");
            /// 태초의 뉴욕에... 피자가게가 있으라.
            PizzaStore nyPizzaStore = new NYPizzaStore();

            /// 치즈 피자를 주문한다.
            nyPizzaStore.OrderPizza("cheese");

            /// at OrderPizza()
            /// Pizza pizza = createPizza("cheese");
                /// 
                /// at CreatePizza()
                /// Pizza pizza = new CheesePizza(nyIngredientFactory);
                    /// 
                    /// at CheesePizza.Prepare()
                    /// dough = factory.CreateDough();      // 씬 크러스트
                    /// sauce = factory.CreateSauce();      // 마리나라 소스
                    /// cheese = factory.CreateCheese();    // 레지아노 치즈
        }
    }
******************************/

















































