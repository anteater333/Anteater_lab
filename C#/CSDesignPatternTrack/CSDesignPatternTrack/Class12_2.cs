/*****************************
* 2017.12.28 디자인 패턴
* 목표 : Chapter 11 - Proxy 패턴 (2)
     ******* 코멘트 *******
오늘도 늦게 시작. 오후 7시 13분.
몸상태도 안좋고... 아 손톱이 아파서 타자치기가 힘들다.
낮잠도 엄청나게 자가지고 하루 쉴까 생각이 들긴 하는데,
그래도 어제 Remoting 정성들여서 배웠으니까 연달아 해야지.
******************************/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

/*****************************
어제 배운 내용에 이어서...
Remoting을 p.479에 비교해보면,
원격 인터페이스는 RemotableType,
서비스 구현 클래스는 Listener,
스터브, 스켈레톤, RMI 레지스트리 역할을 Config에서 맡는 것 같다...
Remoting 말고 WCF를 배울 껄 그랬나.
******************************/

/*****************************
어쨌든 GumballMachine 원격 프록시를 만들어 보자.
웹 프로그래밍은 이제 앞으로 따로 배워보기로 하고.
책에서는 대충 모델만 따라 가져와서 Remoting 코드에 맞춰서 구현하도록 한다.
******************************/

namespace CSDesignPatternTrack
{
    partial class Class12
    {
    }
}

/*****************************
실습 결과는 Remoting/Class12에 있음. 더럽게 힘드네.
어제 배운대로 Config 파일을 쓰는게 아니라,
RemotingServices 네임스페이스의 메소드로 객체에 uri를 할당했다. 한 20% 정도는 이해한 것 같다.

Pattern #14 Proxy
어떤 객체에 대한 접근을 제어하기 위한 용도로 대리인이나 대변인에 해당하는 객체를 제공하는 패턴.

프록시 패턴을 이용하면 원격 개체(원격 프록시), 생성하기 힘든 객체(가상 프록시), 보안이 중요한 객체(보호 프록시)와 같은
다른 객체에 대한 접근을 제어하는 대변자 객체를 만들 수 있다.

배운 과정에 비해 개념은 몹시 간단하다. 어떻게 구현하느냐가 문제지.

끝으로, 프록시 패턴의 다이어그램을 훑어보자. p.499
RealSubject와 Proxy의 인터페이스를 제공하는 Subject 인터페이스가 있다.
두 객체에서 똑같은 인터페이스를 구현하기 때문에 RealSubject가 들어갈 자리에 Proxy가 대신 들어갈 수 있다.
실제 작업은 RealSubject가 처리한다. Proxy는 이 객체의 대변인 역할을 하면서 이 객체에 대한 접근을 제어한다.
Proxy에는 RealSubject에 대한 레퍼런스가 들어있고, Proxy에서 RealSubjeect를 생성하거나 제거하는 역할을 맡기도 한다.
클라이언트는 항상 Proxy를 통해서 RealSubject와 데이터를 주고받는다.
기억해야할 중요한 포인트는 RealSubject 객체가 들어갈 자리면 Proxy가 대신 들어갈 수 있다는 내용.
Proxy는 RealSubject에 대한 접근을 제어하는 역할도 맡게 된다.
RealSubject가 원격 시스템에서 돌아가거나, 그 객체를 생성하는데 비용이 많이 들거나,
접근이 통제되어 있는 경우에 접근을 제어해주는 역할을 한다.

책에서는 남은 내용이 꽤 있긴 한데...
자바랑 밀접한 부분이 좀 있고...
프록시에 대해선 나중에 웹 프로그래밍을 제대로 배우면 그 때 자세히 알아보자.
******************************/

// Anteater