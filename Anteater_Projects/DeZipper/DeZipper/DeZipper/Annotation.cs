/**************************************************
         * DeZipper. Command Line Version *
***************************************************/

/***************************************************
* 날짜 : 2017.11.02
* 목표 : 프로젝트 생성
             ******* 코멘트 *******
부산 다녀오느라 휴가였음. 실은 어제 수요일에 시작했어야하나 너무 피곤했던 관계로 오늘 시작.
할일은 https://github.com/anteater333/Anteater_lab/projects/1 여기에 정리돼있음. github 짱짱.

일단은 CMD 창에서 실행할 수 있는 프로그램을 만드는 거 부터 하자. 그 편이 쉬우니까.
프로그램 다 작성 후에 WinForms. GUI에 연결하자.

그리고 이제 이런 프로젝트는 Anteater_Projects 폴더에서 작업.
완성 후엔 이런 주석같은 군더더기 제거해서 Anteater_Releases 폴더에 복사.

앞으로 해야할 일
시나리오 작성.
ZipFile 클래스 공부.
***************************************************/

/***************************************************
* 날짜 : 2017.11.06
* 목표 : Zip 관련 클래스 학습
             ******* 코멘트 *******
ZipTest.cs 에서 작업.

ZipFile 클래스는 정적 클래스다. 인스턴스 만들 일 없다. Zip 관련된 static 메소드를 제공한다.
zip 파일을 나타내는 객체는 ZipArchive 클래스의 인스턴스로 나타낸다.

ZipArchive 클래스 예제에서 using문을 사용하는 것을 봤다.
using문은 메모리 할당-해제를 프로그래머가 예측 가능하도록 만든다.
using(객체선언)
{
    코드
}
using문과 함께 선언된 객체는 해당 블록이 끝날때 메모리가 해제된다.
불확실한 GC의 단점을 커버하는 방법인듯.

참고로 메모리를 할당하는 모든 객체는 기본적으로 IDispossable이라는 클래스를 상속받는다.
이 IDispossable이라는 객체가 바로 메모리를 해제하는 역활을 한다.
출처: http://hackss.tistory.com/942 [동동이의 블러그]

1)ZipFile의 정적 메소드로 읽어
2)ZipArchive로 반환받은 zip파일의 각 파일들은
3)ZipArchiveEntry 클래스 타입을 가진다. (Entries 속성)
ZipArchiveEntry는 컬렉션으로 foreach문이 사용가능하다.

그렇다면 ZipArchive의 프로퍼티 Entries 에서 특정 엔트리를 하나 삭제하면 실제 zip 파일에도 영향을 줄까?

우선 특정 엔트리에서 delete 메소드를 호출해서 삭제할 수 있다.
이 경우 zip 파일을 update 모드로 열어야하고, 실제 zip파일에 영향을 주지 않는다.
줄것같은데 안준다 어쨌든.

(참고) foreach문에선 컬렉션을 수정해선 안된다. 에러난다. 그 경우 for 문으로 바꿔줘야함.
***************************************************/

/***************************************************
* 날짜 : 2017.11.07
* 목표 : 기능구현
         ******* 코멘트 *******
Entries 프로퍼티에서 얻은 경로를 수정해 파일을 삭제해보자.
사실상 이번 프로젝트의 핵심 기능.

우선 entry.FullName은 경로를 포함한 파일이름을 가져온다.
entry.Name은 폴더일 경우 아무 값도 가지지 않고(아마 NULL인듯), 파일일 경우 파일명만 가져온다.
==> entry.Name == null 로 비교하면 될 줄 알았지만 안됨. entry.Name == "" 로 비교하니까 됨.

entries는 DFS로 zip의 파일을 하나씩 넣은듯. 폴더 파일 구분은 안됐고 그냥 알파벳순으로.
해당 폴더의 파일을 돌다가 또다른 폴더가 있으면 그 폴더로 먼저 들어가서 탐색.

일단 오늘은 폴더는 그대로 놔두고, 파일만 삭제하는 기능을 구현해보자.

생각해볼 문제.
파일 삭제는 쉬움. 근데 폴더를 만났을때, 그걸 구별하는건 일단 할 수 있겠는데,
폴더가 비었는지를 판단하는걸 어떻게 하지.
예외처리는 천천히 핵심 기능을 완성시키고 하자. 일종의 마감처리같이.

참고로 File.Delete() 메소드는
If the file to be deleted does not exist, no exception is thrown.
라고 한다. 로그에 뭐라고 적을지 생각을 해보자.
***************************************************/

/***************************************************
* 날짜 : 2017.11.08
* 목표 : 기능구현. 폴더 삭제
         ******* 코멘트 *******
아이디어1
entries에서 폴더를 찾으면 해당 경로로 Directory 클래스 메소드를 사용하면 되지 않을까
https://msdn.microsoft.com/ko-kr/library/62t64db3(v=vs.110).aspx
Directory.Delete(string)
빈 디렉토리를 삭제.

아이디어2
먼저 파일들을 다 삭제하고,
다시 탐색을 시작해서 폴더들을 삭제.
구현하기 편하긴 할듯. 효율은 모르겠지만...

그리고 휴지통 보내기의 경우
 Microsoft.VisualBasic.FileIO
이 네임스페이스에 있는 클래스 FileSystem의 메소드를 사용하면 된다고한다.
근데 별로 마음에 들진 않는데...
차라리 휴지통 기능을 없애는건 어떨까.

갑자기 생각남.
삭제시 옵션은 Flag Enum으로 만들면 될듯.

아이디어3
파일 삭제하면서 폴더들을 스택에 넣음.
그럼 제일 하위 폴더부터 삭제할수 있다!

일단 써먹을 수 있는 정도는 만들어진듯하다.
파일 폴더 깔끔하게 삭제됨.

테스트는 이정도로 하고 CMD용 프로그램 구현 + 예외처리.
***************************************************/

/***************************************************
* 날짜 : 2017.11.09
* 목표 : CMD 실행 가능 프로그램 만들기
         ******* 코멘트 *******
이때까지 ZipTest에서 했던 내용을 토대로 실제 프로그램 구현하기.
코드 자체는 뭐 크게 변할거 있나 싶다만, 좀 깔끔하게.

한 번 생각해볼 점은, GUI 버전과 CMD 버전 둘이 같은 클래스의 메소드를 사용하도록 코드를 만드는게 좋지 않을까.

따라서 호출관계
DeZipperMain(프로그램 메인) -> DeZipperCMD || DeZipperGUI(UI담당 클래스) -> DeZipper(알고리즘 담당 클래스)

DeZipper 클래스에서는 파일 열기, 삭제만 하는거.
예외처리를 throw 하고 그걸 UI 담당 클래스에서 catch. 예외처리.
DeZipperCMD와 DeZipperGUI는 DeZipperUI 클래스에서 상속받도록 하는게 좋지 않을까.

Entries에서 항목 하나를 제외할때, 리스트를 순차적으로 탐색해서 삭제하면 비효율적일것같은데
효과적인 접근방법이 없을까. 이름으로 접근한다던가.
생성자에서 Entries를 Dictionary 타입으로 만들면 어떨까, 비효율적일까?

삭제와 출력을 따로하려니까 머리가 아프다.
삭제부분에선 for문을 돌리면서 yield return을 하고,
출력부분에선 foreach문을 돌리면 될까.

삭제 후 원본 zip 파일 삭제 기능을 만들다가 든 생각.
보아하니 DeZipper 인스턴스 생성 후 ZipArchive 필드가 계속 zip 파일을 열어두는데,
그럴 필요가 있나?
그냥 열어서 파일 리스트만 뽑아오고 닫는게 더 좋지 않을까?
어차피 생성자 말고 zipAchv 변수를 쓰는곳이 없다.

DeZipper 클래스는 어느정도 완성됨.
참고로 ExcuteDelete() 메소드는 yield return이 들어간 IEnumerable<string> 타입이니까
foreach문에서 호출해야한다.
***************************************************/
